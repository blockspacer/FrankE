// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_FBENGINETYPES_XFBTYPE_H_
#define FLATBUFFERS_GENERATED_FBENGINETYPES_XFBTYPE_H_

#include "flatbuffers/flatbuffers.h"


namespace XFBType {

struct Vec3f;
struct Quat4f;
struct Colour;
struct Clipping;
struct PhysicsConstraint;
struct PhysicsObject;
struct LocalFile;
struct Material;
struct MeshFile;
struct MeshCube;
struct MeshPlane;
struct MeshSphere;
struct Mesh;
struct RenderableComponent;
struct Sound;
struct SpawnComponent;
struct SpawnPointComponent;
struct Trigger;
struct PhysicsComponent;
struct SoundListener;
struct Light;
struct Camera;
struct System;
struct AmbientLight;
struct Scene;
struct Connection;
struct Parameter;
struct Constant;
struct AnimTrigger;
struct Animation;
struct AnimationNode;
struct ParameterNode;
struct TransitionSelectNode;
struct AverageNode;
struct MaskAddNode;
struct SmoothValueNode;
struct LookAtNode;
struct RandomSelectNode;
struct MixNode;
struct AnimNode;
struct BodyComponent;
struct AnimationComponent;
struct SoundComponent;

///optional filtering to cull potential collisions
enum CollisionFilterGroups {
  CollisionFilterGroups_AllFilter = -1,
  CollisionFilterGroups_DefaultFilter = 1,
  CollisionFilterGroups_StaticFilter = 2,
  CollisionFilterGroups_KinematicFilter = 4,
  CollisionFilterGroups_DebrisFilter = 8,
  CollisionFilterGroups_SensorTrigger = 16,
  CollisionFilterGroups_CharacterFilter = 32
};

inline const char **EnumNamesCollisionFilterGroups() {
  static const char *names[] = { "AllFilter", "", "DefaultFilter", "StaticFilter", "", "KinematicFilter", "", "", "", "DebrisFilter", "", "", "", "", "", "", "", "SensorTrigger", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "CharacterFilter", nullptr };
  return names;
}

inline const char *EnumNameCollisionFilterGroups(CollisionFilterGroups e) { return EnumNamesCollisionFilterGroups()[static_cast<int>(e) - static_cast<int>(CollisionFilterGroups_AllFilter)]; }

enum PhysicsType {
  PhysicsType_PT_NO_COLLISION = 0,
  PhysicsType_PT_STATIC = 1,
  PhysicsType_PT_DYNAMIC = 2,
  PhysicsType_PT_RIGID = 3,
  PhysicsType_PT_SOFT = 4,
  PhysicsType_PT_SENSOR = 5,
  PhysicsType_PT_NAVMESH = 6,
  PhysicsType_PT_CHARACTER = 7
};

inline const char **EnumNamesPhysicsType() {
  static const char *names[] = { "PT_NO_COLLISION", "PT_STATIC", "PT_DYNAMIC", "PT_RIGID", "PT_SOFT", "PT_SENSOR", "PT_NAVMESH", "PT_CHARACTER", nullptr };
  return names;
}

inline const char *EnumNamePhysicsType(PhysicsType e) { return EnumNamesPhysicsType()[static_cast<int>(e)]; }

enum PhysicsShape {
  PhysicsShape_SH_BOX = 0,
  PhysicsShape_SH_CONE = 1,
  PhysicsShape_SH_CYLINDER = 2,
  PhysicsShape_SH_SPHERE = 3,
  PhysicsShape_SH_CONVEX_TRIMESH = 4,
  PhysicsShape_SH_GIMPACT_MESH = 5,
  PhysicsShape_SH_BVH_MESH = 6,
  PhysicsShape_SH_CAPSULE = 7,
  PhysicsShape_SH_PLANE = 8
};

inline const char **EnumNamesPhysicsShape() {
  static const char *names[] = { "SH_BOX", "SH_CONE", "SH_CYLINDER", "SH_SPHERE", "SH_CONVEX_TRIMESH", "SH_GIMPACT_MESH", "SH_BVH_MESH", "SH_CAPSULE", "SH_PLANE", nullptr };
  return names;
}

inline const char *EnumNamePhysicsShape(PhysicsShape e) { return EnumNamesPhysicsShape()[static_cast<int>(e)]; }

enum PCType {
  PCType_GK_BALL_CONSTRAINT = 0,
  PCType_GK_HINGE_CONSTRAINT = 1,
  PCType_GK_CONETWIST_CONSTRAINT = 2,
  PCType_GK_VEHICLE_CONSTRAINT = 3,
  PCType_GK_D6_CONSTRAINT = 4,
  PCType_GK_SLIDER_CONSTRAINT = 5,
  PCType_GK_CONTACT_CONSTRAINT = 6
};

inline const char **EnumNamesPCType() {
  static const char *names[] = { "GK_BALL_CONSTRAINT", "GK_HINGE_CONSTRAINT", "GK_CONETWIST_CONSTRAINT", "GK_VEHICLE_CONSTRAINT", "GK_D6_CONSTRAINT", "GK_SLIDER_CONSTRAINT", "GK_CONTACT_CONSTRAINT", nullptr };
  return names;
}

inline const char *EnumNamePCType(PCType e) { return EnumNamesPCType()[static_cast<int>(e)]; }

enum FileLocation {
  FileLocation_FILELOC_Asset = 0,
  FileLocation_FILELOC_DBDataFile = 1
};

inline const char **EnumNamesFileLocation() {
  static const char *names[] = { "FILELOC_Asset", "FILELOC_DBDataFile", nullptr };
  return names;
}

inline const char *EnumNameFileLocation(FileLocation e) { return EnumNamesFileLocation()[static_cast<int>(e)]; }

enum TextureType {
  TextureType_Unlit = 0,
  TextureType_Pbs = 1
};

inline const char **EnumNamesTextureType() {
  static const char *names[] = { "Unlit", "Pbs", nullptr };
  return names;
}

inline const char *EnumNameTextureType(TextureType e) { return EnumNamesTextureType()[static_cast<int>(e)]; }

enum UMesh {
  UMesh_NONE = 0,
  UMesh_MeshFile = 1,
  UMesh_MeshCube = 2,
  UMesh_MeshPlane = 3,
  UMesh_MeshSphere = 4
};

inline const char **EnumNamesUMesh() {
  static const char *names[] = { "NONE", "MeshFile", "MeshCube", "MeshPlane", "MeshSphere", nullptr };
  return names;
}

inline const char *EnumNameUMesh(UMesh e) { return EnumNamesUMesh()[static_cast<int>(e)]; }

inline bool VerifyUMesh(flatbuffers::Verifier &verifier, const void *union_obj, UMesh type);

enum MemoryMgrType {
  MemoryMgrType_SCENE_DYNAMIC = 0,
  MemoryMgrType_SCENE_STATIC = 1
};

inline const char **EnumNamesMemoryMgrType() {
  static const char *names[] = { "SCENE_DYNAMIC", "SCENE_STATIC", nullptr };
  return names;
}

inline const char *EnumNameMemoryMgrType(MemoryMgrType e) { return EnumNamesMemoryMgrType()[static_cast<int>(e)]; }

enum SpawnType {
  SpawnType_STYPE_RANDOM = 0,
  SpawnType_STYPE_ROUND_ROBIN = 1
};

inline const char **EnumNamesSpawnType() {
  static const char *names[] = { "STYPE_RANDOM", "STYPE_ROUND_ROBIN", nullptr };
  return names;
}

inline const char *EnumNameSpawnType(SpawnType e) { return EnumNamesSpawnType()[static_cast<int>(e)]; }

enum LightType {
  LightType_LT_DIRECTIONAL = 0,
  LightType_LT_POINT = 1,
  LightType_LT_SPOTLIGHT = 2
};

inline const char **EnumNamesLightType() {
  static const char *names[] = { "LT_DIRECTIONAL", "LT_POINT", "LT_SPOTLIGHT", nullptr };
  return names;
}

inline const char *EnumNameLightType(LightType e) { return EnumNamesLightType()[static_cast<int>(e)]; }

enum TimeType {
  TimeType_absolute = 0,
  TimeType_relative = 1
};

inline const char **EnumNamesTimeType() {
  static const char *names[] = { "absolute", "relative", nullptr };
  return names;
}

inline const char *EnumNameTimeType(TimeType e) { return EnumNamesTimeType()[static_cast<int>(e)]; }

enum UAnimationNode {
  UAnimationNode_NONE = 0,
  UAnimationNode_AnimationNode = 1,
  UAnimationNode_TransitionSelectNode = 2,
  UAnimationNode_LookAtNode = 3,
  UAnimationNode_MixNode = 4,
  UAnimationNode_ParameterNode = 5,
  UAnimationNode_AverageNode = 6,
  UAnimationNode_MaskAddNode = 7,
  UAnimationNode_RandomSelectNode = 8,
  UAnimationNode_SmoothValueNode = 9
};

inline const char **EnumNamesUAnimationNode() {
  static const char *names[] = { "NONE", "AnimationNode", "TransitionSelectNode", "LookAtNode", "MixNode", "ParameterNode", "AverageNode", "MaskAddNode", "RandomSelectNode", "SmoothValueNode", nullptr };
  return names;
}

inline const char *EnumNameUAnimationNode(UAnimationNode e) { return EnumNamesUAnimationNode()[static_cast<int>(e)]; }

inline bool VerifyUAnimationNode(flatbuffers::Verifier &verifier, const void *union_obj, UAnimationNode type);

MANUALLY_ALIGNED_STRUCT(4) Vec3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3f(float _x, float _y, float _z)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(Vec3f, 12);

MANUALLY_ALIGNED_STRUCT(4) Quat4f FLATBUFFERS_FINAL_CLASS {
 private:
  float w_;
  float x_;
  float y_;
  float z_;

 public:
  Quat4f(float _w, float _x, float _y, float _z)
    : w_(flatbuffers::EndianScalar(_w)), x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)) { }

  float w() const { return flatbuffers::EndianScalar(w_); }
  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(Quat4f, 16);

MANUALLY_ALIGNED_STRUCT(4) Colour FLATBUFFERS_FINAL_CLASS {
 private:
  float r_;
  float g_;
  float b_;
  float a_;

 public:
  Colour(float _r, float _g, float _b, float _a)
    : r_(flatbuffers::EndianScalar(_r)), g_(flatbuffers::EndianScalar(_g)), b_(flatbuffers::EndianScalar(_b)), a_(flatbuffers::EndianScalar(_a)) { }

  float r() const { return flatbuffers::EndianScalar(r_); }
  float g() const { return flatbuffers::EndianScalar(g_); }
  float b() const { return flatbuffers::EndianScalar(b_); }
  float a() const { return flatbuffers::EndianScalar(a_); }
};
STRUCT_END(Colour, 16);

MANUALLY_ALIGNED_STRUCT(4) Connection FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t nodeIn_;
  uint32_t nodeOut_;
  uint32_t portIn_;

 public:
  Connection(uint32_t _nodeIn, uint32_t _nodeOut, uint32_t _portIn)
    : nodeIn_(flatbuffers::EndianScalar(_nodeIn)), nodeOut_(flatbuffers::EndianScalar(_nodeOut)), portIn_(flatbuffers::EndianScalar(_portIn)) { }

  uint32_t nodeIn() const { return flatbuffers::EndianScalar(nodeIn_); }
  uint32_t nodeOut() const { return flatbuffers::EndianScalar(nodeOut_); }
  uint32_t portIn() const { return flatbuffers::EndianScalar(portIn_); }
};
STRUCT_END(Connection, 12);

MANUALLY_ALIGNED_STRUCT(4) Parameter FLATBUFFERS_FINAL_CLASS {
 private:
  float value_;

 public:
  Parameter(float _value)
    : value_(flatbuffers::EndianScalar(_value)) { }

  float value() const { return flatbuffers::EndianScalar(value_); }
};
STRUCT_END(Parameter, 4);

MANUALLY_ALIGNED_STRUCT(4) Constant FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  uint32_t nodeId_;
  uint32_t portId_;
  float value_;

 public:
  Constant(uint32_t _id, uint32_t _nodeId, uint32_t _portId, float _value)
    : id_(flatbuffers::EndianScalar(_id)), nodeId_(flatbuffers::EndianScalar(_nodeId)), portId_(flatbuffers::EndianScalar(_portId)), value_(flatbuffers::EndianScalar(_value)) { }

  uint32_t id() const { return flatbuffers::EndianScalar(id_); }
  uint32_t nodeId() const { return flatbuffers::EndianScalar(nodeId_); }
  uint32_t portId() const { return flatbuffers::EndianScalar(portId_); }
  float value() const { return flatbuffers::EndianScalar(value_); }
};
STRUCT_END(Constant, 16);

MANUALLY_ALIGNED_STRUCT(4) AnimTrigger FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  float time_;
  uint8_t timeType_;
  int8_t __padding0;
  int16_t __padding1;
  float minWeightThreshold_;

 public:
  AnimTrigger(uint32_t _id, float _time, TimeType _timeType, float _minWeightThreshold)
    : id_(flatbuffers::EndianScalar(_id)), time_(flatbuffers::EndianScalar(_time)), timeType_(flatbuffers::EndianScalar(static_cast<uint8_t>(_timeType))), __padding0(0), __padding1(0), minWeightThreshold_(flatbuffers::EndianScalar(_minWeightThreshold)) { (void)__padding0; (void)__padding1; }

  uint32_t id() const { return flatbuffers::EndianScalar(id_); }
  float time() const { return flatbuffers::EndianScalar(time_); }
  TimeType timeType() const { return static_cast<TimeType>(flatbuffers::EndianScalar(timeType_)); }
  float minWeightThreshold() const { return flatbuffers::EndianScalar(minWeightThreshold_); }
};
STRUCT_END(AnimTrigger, 16);

struct Clipping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  float nearClip() const { return GetField<float>(4, 0); }
  float farClip() const { return GetField<float>(6, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4 /* nearClip */) &&
           VerifyField<float>(verifier, 6 /* farClip */) &&
           verifier.EndTable();
  }
};

struct ClippingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nearClip(float nearClip) { fbb_.AddElement<float>(4, nearClip, 0); }
  void add_farClip(float farClip) { fbb_.AddElement<float>(6, farClip, 0); }
  ClippingBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ClippingBuilder &operator=(const ClippingBuilder &);
  flatbuffers::Offset<Clipping> Finish() {
    auto o = flatbuffers::Offset<Clipping>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Clipping> CreateClipping(flatbuffers::FlatBufferBuilder &_fbb,
   float nearClip = 0,
   float farClip = 0) {
  ClippingBuilder builder_(_fbb);
  builder_.add_farClip(farClip);
  builder_.add_nearClip(nearClip);
  return builder_.Finish();
}

struct PhysicsConstraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *target() const { return GetPointer<const flatbuffers::String *>(4); }
  PCType type() const { return static_cast<PCType>(GetField<int8_t>(6, 0)); }
  const Vec3f *pivot() const { return GetStruct<const Vec3f *>(8); }
  const Vec3f *axis() const { return GetStruct<const Vec3f *>(10); }
  int16_t flag() const { return GetField<int16_t>(12, 0); }
  const flatbuffers::Vector<float> *minLimit() const { return GetPointer<const flatbuffers::Vector<float> *>(14); }
  const flatbuffers::Vector<float> *maxLimit() const { return GetPointer<const flatbuffers::Vector<float> *>(16); }
  uint8_t disableLinkedCollision() const { return GetField<uint8_t>(18, 0); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(20); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* target */) &&
           verifier.Verify(target()) &&
           VerifyField<int8_t>(verifier, 6 /* type */) &&
           VerifyField<Vec3f>(verifier, 8 /* pivot */) &&
           VerifyField<Vec3f>(verifier, 10 /* axis */) &&
           VerifyField<int16_t>(verifier, 12 /* flag */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* minLimit */) &&
           verifier.Verify(minLimit()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 16 /* maxLimit */) &&
           verifier.Verify(maxLimit()) &&
           VerifyField<uint8_t>(verifier, 18 /* disableLinkedCollision */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 20 /* name */) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct PhysicsConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target(flatbuffers::Offset<flatbuffers::String> target) { fbb_.AddOffset(4, target); }
  void add_type(PCType type) { fbb_.AddElement<int8_t>(6, static_cast<int8_t>(type), 0); }
  void add_pivot(const Vec3f *pivot) { fbb_.AddStruct(8, pivot); }
  void add_axis(const Vec3f *axis) { fbb_.AddStruct(10, axis); }
  void add_flag(int16_t flag) { fbb_.AddElement<int16_t>(12, flag, 0); }
  void add_minLimit(flatbuffers::Offset<flatbuffers::Vector<float>> minLimit) { fbb_.AddOffset(14, minLimit); }
  void add_maxLimit(flatbuffers::Offset<flatbuffers::Vector<float>> maxLimit) { fbb_.AddOffset(16, maxLimit); }
  void add_disableLinkedCollision(uint8_t disableLinkedCollision) { fbb_.AddElement<uint8_t>(18, disableLinkedCollision, 0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(20, name); }
  PhysicsConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PhysicsConstraintBuilder &operator=(const PhysicsConstraintBuilder &);
  flatbuffers::Offset<PhysicsConstraint> Finish() {
    auto o = flatbuffers::Offset<PhysicsConstraint>(fbb_.EndTable(start_, 9));
    return o;
  }
};

inline flatbuffers::Offset<PhysicsConstraint> CreatePhysicsConstraint(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> target = 0,
   PCType type = PCType_GK_BALL_CONSTRAINT,
   const Vec3f *pivot = 0,
   const Vec3f *axis = 0,
   int16_t flag = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> minLimit = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> maxLimit = 0,
   uint8_t disableLinkedCollision = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0) {
  PhysicsConstraintBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_maxLimit(maxLimit);
  builder_.add_minLimit(minLimit);
  builder_.add_axis(axis);
  builder_.add_pivot(pivot);
  builder_.add_target(target);
  builder_.add_flag(flag);
  builder_.add_disableLinkedCollision(disableLinkedCollision);
  builder_.add_type(type);
  return builder_.Finish();
}

struct PhysicsObject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint16_t id() const { return GetField<uint16_t>(4, 0); }
  int16_t colMask() const { return GetField<int16_t>(6, 0); }
  PhysicsType type() const { return static_cast<PhysicsType>(GetField<int8_t>(8, 0)); }
  uint32_t mode() const { return GetField<uint32_t>(10, 0); }
  PhysicsShape shape() const { return static_cast<PhysicsShape>(GetField<int8_t>(12, 0)); }
  float mass() const { return GetField<float>(14, 0); }
  float margin() const { return GetField<float>(16, 0); }
  float radius() const { return GetField<float>(18, 0); }
  float angularDamp() const { return GetField<float>(20, 0); }
  float linearDamp() const { return GetField<float>(22, 0); }
  float formFactor() const { return GetField<float>(24, 0); }
  float minVel() const { return GetField<float>(26, 0); }
  float maxVel() const { return GetField<float>(28, 0); }
  float restitution() const { return GetField<float>(30, 0); }
  float friction() const { return GetField<float>(32, 0); }
  int16_t colGroupMask() const { return GetField<int16_t>(34, 0); }
  float charStepHeight() const { return GetField<float>(36, 0); }
  float charJumpSpeed() const { return GetField<float>(38, 0); }
  float charFallSpeed() const { return GetField<float>(40, 0); }
  const flatbuffers::String *boneparent() const { return GetPointer<const flatbuffers::String *>(42); }
  const flatbuffers::String *collMeshName() const { return GetPointer<const flatbuffers::String *>(44); }
  const Vec3f *size() const { return GetStruct<const Vec3f *>(46); }
  const Vec3f *scale() const { return GetStruct<const Vec3f *>(48); }
  const Vec3f *offset() const { return GetStruct<const Vec3f *>(50); }
  uint8_t parentIsNode() const { return GetField<uint8_t>(52, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<PhysicsConstraint>> *physicsConstraints() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PhysicsConstraint>> *>(54); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(56); }
  const LocalFile *file() const { return GetPointer<const LocalFile *>(58); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* id */) &&
           VerifyField<int16_t>(verifier, 6 /* colMask */) &&
           VerifyField<int8_t>(verifier, 8 /* type */) &&
           VerifyField<uint32_t>(verifier, 10 /* mode */) &&
           VerifyField<int8_t>(verifier, 12 /* shape */) &&
           VerifyField<float>(verifier, 14 /* mass */) &&
           VerifyField<float>(verifier, 16 /* margin */) &&
           VerifyField<float>(verifier, 18 /* radius */) &&
           VerifyField<float>(verifier, 20 /* angularDamp */) &&
           VerifyField<float>(verifier, 22 /* linearDamp */) &&
           VerifyField<float>(verifier, 24 /* formFactor */) &&
           VerifyField<float>(verifier, 26 /* minVel */) &&
           VerifyField<float>(verifier, 28 /* maxVel */) &&
           VerifyField<float>(verifier, 30 /* restitution */) &&
           VerifyField<float>(verifier, 32 /* friction */) &&
           VerifyField<int16_t>(verifier, 34 /* colGroupMask */) &&
           VerifyField<float>(verifier, 36 /* charStepHeight */) &&
           VerifyField<float>(verifier, 38 /* charJumpSpeed */) &&
           VerifyField<float>(verifier, 40 /* charFallSpeed */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 42 /* boneparent */) &&
           verifier.Verify(boneparent()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 44 /* collMeshName */) &&
           verifier.Verify(collMeshName()) &&
           VerifyField<Vec3f>(verifier, 46 /* size */) &&
           VerifyField<Vec3f>(verifier, 48 /* scale */) &&
           VerifyField<Vec3f>(verifier, 50 /* offset */) &&
           VerifyField<uint8_t>(verifier, 52 /* parentIsNode */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 54 /* physicsConstraints */) &&
           verifier.Verify(physicsConstraints()) &&
           verifier.VerifyVectorOfTables(physicsConstraints()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 56 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 58 /* file */) &&
           verifier.VerifyTable(file()) &&
           verifier.EndTable();
  }
};

struct PhysicsObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) { fbb_.AddElement<uint16_t>(4, id, 0); }
  void add_colMask(int16_t colMask) { fbb_.AddElement<int16_t>(6, colMask, 0); }
  void add_type(PhysicsType type) { fbb_.AddElement<int8_t>(8, static_cast<int8_t>(type), 0); }
  void add_mode(uint32_t mode) { fbb_.AddElement<uint32_t>(10, mode, 0); }
  void add_shape(PhysicsShape shape) { fbb_.AddElement<int8_t>(12, static_cast<int8_t>(shape), 0); }
  void add_mass(float mass) { fbb_.AddElement<float>(14, mass, 0); }
  void add_margin(float margin) { fbb_.AddElement<float>(16, margin, 0); }
  void add_radius(float radius) { fbb_.AddElement<float>(18, radius, 0); }
  void add_angularDamp(float angularDamp) { fbb_.AddElement<float>(20, angularDamp, 0); }
  void add_linearDamp(float linearDamp) { fbb_.AddElement<float>(22, linearDamp, 0); }
  void add_formFactor(float formFactor) { fbb_.AddElement<float>(24, formFactor, 0); }
  void add_minVel(float minVel) { fbb_.AddElement<float>(26, minVel, 0); }
  void add_maxVel(float maxVel) { fbb_.AddElement<float>(28, maxVel, 0); }
  void add_restitution(float restitution) { fbb_.AddElement<float>(30, restitution, 0); }
  void add_friction(float friction) { fbb_.AddElement<float>(32, friction, 0); }
  void add_colGroupMask(int16_t colGroupMask) { fbb_.AddElement<int16_t>(34, colGroupMask, 0); }
  void add_charStepHeight(float charStepHeight) { fbb_.AddElement<float>(36, charStepHeight, 0); }
  void add_charJumpSpeed(float charJumpSpeed) { fbb_.AddElement<float>(38, charJumpSpeed, 0); }
  void add_charFallSpeed(float charFallSpeed) { fbb_.AddElement<float>(40, charFallSpeed, 0); }
  void add_boneparent(flatbuffers::Offset<flatbuffers::String> boneparent) { fbb_.AddOffset(42, boneparent); }
  void add_collMeshName(flatbuffers::Offset<flatbuffers::String> collMeshName) { fbb_.AddOffset(44, collMeshName); }
  void add_size(const Vec3f *size) { fbb_.AddStruct(46, size); }
  void add_scale(const Vec3f *scale) { fbb_.AddStruct(48, scale); }
  void add_offset(const Vec3f *offset) { fbb_.AddStruct(50, offset); }
  void add_parentIsNode(uint8_t parentIsNode) { fbb_.AddElement<uint8_t>(52, parentIsNode, 0); }
  void add_physicsConstraints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PhysicsConstraint>>> physicsConstraints) { fbb_.AddOffset(54, physicsConstraints); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(56, name); }
  void add_file(flatbuffers::Offset<LocalFile> file) { fbb_.AddOffset(58, file); }
  PhysicsObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PhysicsObjectBuilder &operator=(const PhysicsObjectBuilder &);
  flatbuffers::Offset<PhysicsObject> Finish() {
    auto o = flatbuffers::Offset<PhysicsObject>(fbb_.EndTable(start_, 28));
    return o;
  }
};

inline flatbuffers::Offset<PhysicsObject> CreatePhysicsObject(flatbuffers::FlatBufferBuilder &_fbb,
   uint16_t id = 0,
   int16_t colMask = 0,
   PhysicsType type = PhysicsType_PT_NO_COLLISION,
   uint32_t mode = 0,
   PhysicsShape shape = PhysicsShape_SH_BOX,
   float mass = 0,
   float margin = 0,
   float radius = 0,
   float angularDamp = 0,
   float linearDamp = 0,
   float formFactor = 0,
   float minVel = 0,
   float maxVel = 0,
   float restitution = 0,
   float friction = 0,
   int16_t colGroupMask = 0,
   float charStepHeight = 0,
   float charJumpSpeed = 0,
   float charFallSpeed = 0,
   flatbuffers::Offset<flatbuffers::String> boneparent = 0,
   flatbuffers::Offset<flatbuffers::String> collMeshName = 0,
   const Vec3f *size = 0,
   const Vec3f *scale = 0,
   const Vec3f *offset = 0,
   uint8_t parentIsNode = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PhysicsConstraint>>> physicsConstraints = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<LocalFile> file = 0) {
  PhysicsObjectBuilder builder_(_fbb);
  builder_.add_file(file);
  builder_.add_name(name);
  builder_.add_physicsConstraints(physicsConstraints);
  builder_.add_offset(offset);
  builder_.add_scale(scale);
  builder_.add_size(size);
  builder_.add_collMeshName(collMeshName);
  builder_.add_boneparent(boneparent);
  builder_.add_charFallSpeed(charFallSpeed);
  builder_.add_charJumpSpeed(charJumpSpeed);
  builder_.add_charStepHeight(charStepHeight);
  builder_.add_friction(friction);
  builder_.add_restitution(restitution);
  builder_.add_maxVel(maxVel);
  builder_.add_minVel(minVel);
  builder_.add_formFactor(formFactor);
  builder_.add_linearDamp(linearDamp);
  builder_.add_angularDamp(angularDamp);
  builder_.add_radius(radius);
  builder_.add_margin(margin);
  builder_.add_mass(mass);
  builder_.add_mode(mode);
  builder_.add_colGroupMask(colGroupMask);
  builder_.add_colMask(colMask);
  builder_.add_id(id);
  builder_.add_parentIsNode(parentIsNode);
  builder_.add_shape(shape);
  builder_.add_type(type);
  return builder_.Finish();
}

struct LocalFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  FileLocation fileLocation() const { return static_cast<FileLocation>(GetField<int8_t>(4, 0)); }
  const flatbuffers::String *fileName() const { return GetPointer<const flatbuffers::String *>(6); }
  const flatbuffers::String *filePath() const { return GetPointer<const flatbuffers::String *>(8); }
  const flatbuffers::String *resourceGrp() const { return GetPointer<const flatbuffers::String *>(10); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4 /* fileLocation */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* fileName */) &&
           verifier.Verify(fileName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* filePath */) &&
           verifier.Verify(filePath()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* resourceGrp */) &&
           verifier.Verify(resourceGrp()) &&
           verifier.EndTable();
  }
};

struct LocalFileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fileLocation(FileLocation fileLocation) { fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fileLocation), 0); }
  void add_fileName(flatbuffers::Offset<flatbuffers::String> fileName) { fbb_.AddOffset(6, fileName); }
  void add_filePath(flatbuffers::Offset<flatbuffers::String> filePath) { fbb_.AddOffset(8, filePath); }
  void add_resourceGrp(flatbuffers::Offset<flatbuffers::String> resourceGrp) { fbb_.AddOffset(10, resourceGrp); }
  LocalFileBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LocalFileBuilder &operator=(const LocalFileBuilder &);
  flatbuffers::Offset<LocalFile> Finish() {
    auto o = flatbuffers::Offset<LocalFile>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<LocalFile> CreateLocalFile(flatbuffers::FlatBufferBuilder &_fbb,
   FileLocation fileLocation = FileLocation_FILELOC_Asset,
   flatbuffers::Offset<flatbuffers::String> fileName = 0,
   flatbuffers::Offset<flatbuffers::String> filePath = 0,
   flatbuffers::Offset<flatbuffers::String> resourceGrp = 0) {
  LocalFileBuilder builder_(_fbb);
  builder_.add_resourceGrp(resourceGrp);
  builder_.add_filePath(filePath);
  builder_.add_fileName(fileName);
  builder_.add_fileLocation(fileLocation);
  return builder_.Finish();
}

struct Material FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const LocalFile *file() const { return GetPointer<const LocalFile *>(4); }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *textures() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(6); }
  TextureType textureType() const { return static_cast<TextureType>(GetField<int8_t>(8, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* file */) &&
           verifier.VerifyTable(file()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* textures */) &&
           verifier.Verify(textures()) &&
           verifier.VerifyVectorOfStrings(textures()) &&
           VerifyField<int8_t>(verifier, 8 /* textureType */) &&
           verifier.EndTable();
  }
};

struct MaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<LocalFile> file) { fbb_.AddOffset(4, file); }
  void add_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> textures) { fbb_.AddOffset(6, textures); }
  void add_textureType(TextureType textureType) { fbb_.AddElement<int8_t>(8, static_cast<int8_t>(textureType), 0); }
  MaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MaterialBuilder &operator=(const MaterialBuilder &);
  flatbuffers::Offset<Material> Finish() {
    auto o = flatbuffers::Offset<Material>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Material> CreateMaterial(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<LocalFile> file = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> textures = 0,
   TextureType textureType = TextureType_Unlit) {
  MaterialBuilder builder_(_fbb);
  builder_.add_textures(textures);
  builder_.add_file(file);
  builder_.add_textureType(textureType);
  return builder_.Finish();
}

struct MeshFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const LocalFile *file() const { return GetPointer<const LocalFile *>(4); }
  const Material *material() const { return GetPointer<const Material *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* file */) &&
           verifier.VerifyTable(file()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* material */) &&
           verifier.VerifyTable(material()) &&
           verifier.EndTable();
  }
};

struct MeshFileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<LocalFile> file) { fbb_.AddOffset(4, file); }
  void add_material(flatbuffers::Offset<Material> material) { fbb_.AddOffset(6, material); }
  MeshFileBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MeshFileBuilder &operator=(const MeshFileBuilder &);
  flatbuffers::Offset<MeshFile> Finish() {
    auto o = flatbuffers::Offset<MeshFile>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<MeshFile> CreateMeshFile(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<LocalFile> file = 0,
   flatbuffers::Offset<Material> material = 0) {
  MeshFileBuilder builder_(_fbb);
  builder_.add_material(material);
  builder_.add_file(file);
  return builder_.Finish();
}

struct MeshCube FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *Name() const { return GetPointer<const flatbuffers::String *>(4); }
  const Material *material() const { return GetPointer<const Material *>(6); }
  float width() const { return GetField<float>(8, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* Name */) &&
           verifier.Verify(Name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* material */) &&
           verifier.VerifyTable(material()) &&
           VerifyField<float>(verifier, 8 /* width */) &&
           verifier.EndTable();
  }
};

struct MeshCubeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) { fbb_.AddOffset(4, Name); }
  void add_material(flatbuffers::Offset<Material> material) { fbb_.AddOffset(6, material); }
  void add_width(float width) { fbb_.AddElement<float>(8, width, 0); }
  MeshCubeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MeshCubeBuilder &operator=(const MeshCubeBuilder &);
  flatbuffers::Offset<MeshCube> Finish() {
    auto o = flatbuffers::Offset<MeshCube>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<MeshCube> CreateMeshCube(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> Name = 0,
   flatbuffers::Offset<Material> material = 0,
   float width = 0) {
  MeshCubeBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_material(material);
  builder_.add_Name(Name);
  return builder_.Finish();
}

struct MeshPlane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *Name() const { return GetPointer<const flatbuffers::String *>(4); }
  const Material *material() const { return GetPointer<const Material *>(6); }
  const Vec3f *normal() const { return GetStruct<const Vec3f *>(8); }
  float constant() const { return GetField<float>(10, 0); }
  float width() const { return GetField<float>(12, 0); }
  float height() const { return GetField<float>(14, 0); }
  uint32_t xsegments() const { return GetField<uint32_t>(16, 0); }
  uint32_t ysegments() const { return GetField<uint32_t>(18, 0); }
  uint8_t normals() const { return GetField<uint8_t>(20, 0); }
  uint32_t numTexCoordSets() const { return GetField<uint32_t>(22, 0); }
  float xTile() const { return GetField<float>(24, 0); }
  float yTile() const { return GetField<float>(26, 0); }
  const Vec3f *upVector() const { return GetStruct<const Vec3f *>(28); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* Name */) &&
           verifier.Verify(Name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* material */) &&
           verifier.VerifyTable(material()) &&
           VerifyField<Vec3f>(verifier, 8 /* normal */) &&
           VerifyField<float>(verifier, 10 /* constant */) &&
           VerifyField<float>(verifier, 12 /* width */) &&
           VerifyField<float>(verifier, 14 /* height */) &&
           VerifyField<uint32_t>(verifier, 16 /* xsegments */) &&
           VerifyField<uint32_t>(verifier, 18 /* ysegments */) &&
           VerifyField<uint8_t>(verifier, 20 /* normals */) &&
           VerifyField<uint32_t>(verifier, 22 /* numTexCoordSets */) &&
           VerifyField<float>(verifier, 24 /* xTile */) &&
           VerifyField<float>(verifier, 26 /* yTile */) &&
           VerifyField<Vec3f>(verifier, 28 /* upVector */) &&
           verifier.EndTable();
  }
};

struct MeshPlaneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) { fbb_.AddOffset(4, Name); }
  void add_material(flatbuffers::Offset<Material> material) { fbb_.AddOffset(6, material); }
  void add_normal(const Vec3f *normal) { fbb_.AddStruct(8, normal); }
  void add_constant(float constant) { fbb_.AddElement<float>(10, constant, 0); }
  void add_width(float width) { fbb_.AddElement<float>(12, width, 0); }
  void add_height(float height) { fbb_.AddElement<float>(14, height, 0); }
  void add_xsegments(uint32_t xsegments) { fbb_.AddElement<uint32_t>(16, xsegments, 0); }
  void add_ysegments(uint32_t ysegments) { fbb_.AddElement<uint32_t>(18, ysegments, 0); }
  void add_normals(uint8_t normals) { fbb_.AddElement<uint8_t>(20, normals, 0); }
  void add_numTexCoordSets(uint32_t numTexCoordSets) { fbb_.AddElement<uint32_t>(22, numTexCoordSets, 0); }
  void add_xTile(float xTile) { fbb_.AddElement<float>(24, xTile, 0); }
  void add_yTile(float yTile) { fbb_.AddElement<float>(26, yTile, 0); }
  void add_upVector(const Vec3f *upVector) { fbb_.AddStruct(28, upVector); }
  MeshPlaneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MeshPlaneBuilder &operator=(const MeshPlaneBuilder &);
  flatbuffers::Offset<MeshPlane> Finish() {
    auto o = flatbuffers::Offset<MeshPlane>(fbb_.EndTable(start_, 13));
    return o;
  }
};

inline flatbuffers::Offset<MeshPlane> CreateMeshPlane(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> Name = 0,
   flatbuffers::Offset<Material> material = 0,
   const Vec3f *normal = 0,
   float constant = 0,
   float width = 0,
   float height = 0,
   uint32_t xsegments = 0,
   uint32_t ysegments = 0,
   uint8_t normals = 0,
   uint32_t numTexCoordSets = 0,
   float xTile = 0,
   float yTile = 0,
   const Vec3f *upVector = 0) {
  MeshPlaneBuilder builder_(_fbb);
  builder_.add_upVector(upVector);
  builder_.add_yTile(yTile);
  builder_.add_xTile(xTile);
  builder_.add_numTexCoordSets(numTexCoordSets);
  builder_.add_ysegments(ysegments);
  builder_.add_xsegments(xsegments);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_constant(constant);
  builder_.add_normal(normal);
  builder_.add_material(material);
  builder_.add_Name(Name);
  builder_.add_normals(normals);
  return builder_.Finish();
}

struct MeshSphere FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *Name() const { return GetPointer<const flatbuffers::String *>(4); }
  const Material *material() const { return GetPointer<const Material *>(6); }
  float rad() const { return GetField<float>(8, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* Name */) &&
           verifier.Verify(Name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* material */) &&
           verifier.VerifyTable(material()) &&
           VerifyField<float>(verifier, 8 /* rad */) &&
           verifier.EndTable();
  }
};

struct MeshSphereBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) { fbb_.AddOffset(4, Name); }
  void add_material(flatbuffers::Offset<Material> material) { fbb_.AddOffset(6, material); }
  void add_rad(float rad) { fbb_.AddElement<float>(8, rad, 0); }
  MeshSphereBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MeshSphereBuilder &operator=(const MeshSphereBuilder &);
  flatbuffers::Offset<MeshSphere> Finish() {
    auto o = flatbuffers::Offset<MeshSphere>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<MeshSphere> CreateMeshSphere(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> Name = 0,
   flatbuffers::Offset<Material> material = 0,
   float rad = 0) {
  MeshSphereBuilder builder_(_fbb);
  builder_.add_rad(rad);
  builder_.add_material(material);
  builder_.add_Name(Name);
  return builder_.Finish();
}

struct Mesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  UMesh mesh_type() const { return static_cast<UMesh>(GetField<uint8_t>(4, 0)); }
  const void *mesh() const { return GetPointer<const void *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* mesh_type */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* mesh */) &&
           VerifyUMesh(verifier, mesh(), mesh_type()) &&
           verifier.EndTable();
  }
};

struct MeshBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mesh_type(UMesh mesh_type) { fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(mesh_type), 0); }
  void add_mesh(flatbuffers::Offset<void> mesh) { fbb_.AddOffset(6, mesh); }
  MeshBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MeshBuilder &operator=(const MeshBuilder &);
  flatbuffers::Offset<Mesh> Finish() {
    auto o = flatbuffers::Offset<Mesh>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Mesh> CreateMesh(flatbuffers::FlatBufferBuilder &_fbb,
   UMesh mesh_type = UMesh_NONE,
   flatbuffers::Offset<void> mesh = 0) {
  MeshBuilder builder_(_fbb);
  builder_.add_mesh(mesh);
  builder_.add_mesh_type(mesh_type);
  return builder_.Finish();
}

struct RenderableComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  MemoryMgrType memType() const { return static_cast<MemoryMgrType>(GetField<uint8_t>(4, 0)); }
  uint32_t renderqueue() const { return GetField<uint32_t>(6, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<Mesh>> *meshes() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Mesh>> *>(8); }
  uint8_t castShadows() const { return GetField<uint8_t>(10, 0); }
  uint32_t mode() const { return GetField<uint32_t>(12, 0); }
  uint8_t showAABB() const { return GetField<uint8_t>(14, 0); }
  uint32_t group() const { return GetField<uint32_t>(16, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* memType */) &&
           VerifyField<uint32_t>(verifier, 6 /* renderqueue */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* meshes */) &&
           verifier.Verify(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           VerifyField<uint8_t>(verifier, 10 /* castShadows */) &&
           VerifyField<uint32_t>(verifier, 12 /* mode */) &&
           VerifyField<uint8_t>(verifier, 14 /* showAABB */) &&
           VerifyField<uint32_t>(verifier, 16 /* group */) &&
           verifier.EndTable();
  }
};

struct RenderableComponentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_memType(MemoryMgrType memType) { fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(memType), 0); }
  void add_renderqueue(uint32_t renderqueue) { fbb_.AddElement<uint32_t>(6, renderqueue, 0); }
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes) { fbb_.AddOffset(8, meshes); }
  void add_castShadows(uint8_t castShadows) { fbb_.AddElement<uint8_t>(10, castShadows, 0); }
  void add_mode(uint32_t mode) { fbb_.AddElement<uint32_t>(12, mode, 0); }
  void add_showAABB(uint8_t showAABB) { fbb_.AddElement<uint8_t>(14, showAABB, 0); }
  void add_group(uint32_t group) { fbb_.AddElement<uint32_t>(16, group, 0); }
  RenderableComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RenderableComponentBuilder &operator=(const RenderableComponentBuilder &);
  flatbuffers::Offset<RenderableComponent> Finish() {
    auto o = flatbuffers::Offset<RenderableComponent>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<RenderableComponent> CreateRenderableComponent(flatbuffers::FlatBufferBuilder &_fbb,
   MemoryMgrType memType = MemoryMgrType_SCENE_DYNAMIC,
   uint32_t renderqueue = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes = 0,
   uint8_t castShadows = 0,
   uint32_t mode = 0,
   uint8_t showAABB = 0,
   uint32_t group = 0) {
  RenderableComponentBuilder builder_(_fbb);
  builder_.add_group(group);
  builder_.add_mode(mode);
  builder_.add_meshes(meshes);
  builder_.add_renderqueue(renderqueue);
  builder_.add_showAABB(showAABB);
  builder_.add_castShadows(castShadows);
  builder_.add_memType(memType);
  return builder_.Finish();
}

struct Sound FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const LocalFile *file() const { return GetPointer<const LocalFile *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* file */) &&
           verifier.VerifyTable(file()) &&
           verifier.EndTable();
  }
};

struct SoundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<LocalFile> file) { fbb_.AddOffset(4, file); }
  SoundBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SoundBuilder &operator=(const SoundBuilder &);
  flatbuffers::Offset<Sound> Finish() {
    auto o = flatbuffers::Offset<Sound>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Sound> CreateSound(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<LocalFile> file = 0) {
  SoundBuilder builder_(_fbb);
  builder_.add_file(file);
  return builder_.Finish();
}

struct SpawnComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint32_t SPGroup() const { return GetField<uint32_t>(4, 0); }
  uint32_t spawnPointId() const { return GetField<uint32_t>(6, 0); }
  SpawnType spawnType() const { return static_cast<SpawnType>(GetField<uint8_t>(8, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4 /* SPGroup */) &&
           VerifyField<uint32_t>(verifier, 6 /* spawnPointId */) &&
           VerifyField<uint8_t>(verifier, 8 /* spawnType */) &&
           verifier.EndTable();
  }
};

struct SpawnComponentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SPGroup(uint32_t SPGroup) { fbb_.AddElement<uint32_t>(4, SPGroup, 0); }
  void add_spawnPointId(uint32_t spawnPointId) { fbb_.AddElement<uint32_t>(6, spawnPointId, 0); }
  void add_spawnType(SpawnType spawnType) { fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(spawnType), 0); }
  SpawnComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SpawnComponentBuilder &operator=(const SpawnComponentBuilder &);
  flatbuffers::Offset<SpawnComponent> Finish() {
    auto o = flatbuffers::Offset<SpawnComponent>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<SpawnComponent> CreateSpawnComponent(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t SPGroup = 0,
   uint32_t spawnPointId = 0,
   SpawnType spawnType = SpawnType_STYPE_RANDOM) {
  SpawnComponentBuilder builder_(_fbb);
  builder_.add_spawnPointId(spawnPointId);
  builder_.add_SPGroup(SPGroup);
  builder_.add_spawnType(spawnType);
  return builder_.Finish();
}

struct SpawnPointComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint32_t SPGroup() const { return GetField<uint32_t>(4, 0); }
  uint32_t id() const { return GetField<uint32_t>(6, 0); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4 /* SPGroup */) &&
           VerifyField<uint32_t>(verifier, 6 /* id */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* name */) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct SpawnPointComponentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SPGroup(uint32_t SPGroup) { fbb_.AddElement<uint32_t>(4, SPGroup, 0); }
  void add_id(uint32_t id) { fbb_.AddElement<uint32_t>(6, id, 0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(8, name); }
  SpawnPointComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SpawnPointComponentBuilder &operator=(const SpawnPointComponentBuilder &);
  flatbuffers::Offset<SpawnPointComponent> Finish() {
    auto o = flatbuffers::Offset<SpawnPointComponent>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<SpawnPointComponent> CreateSpawnPointComponent(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t SPGroup = 0,
   uint32_t id = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0) {
  SpawnPointComponentBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_SPGroup(SPGroup);
  return builder_.Finish();
}

struct Trigger FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct TriggerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  TriggerBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TriggerBuilder &operator=(const TriggerBuilder &);
  flatbuffers::Offset<Trigger> Finish() {
    auto o = flatbuffers::Offset<Trigger>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Trigger> CreateTrigger(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0) {
  TriggerBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

struct PhysicsComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<PhysicsObject>> *physics() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PhysicsObject>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* physics */) &&
           verifier.Verify(physics()) &&
           verifier.VerifyVectorOfTables(physics()) &&
           verifier.EndTable();
  }
};

struct PhysicsComponentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_physics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PhysicsObject>>> physics) { fbb_.AddOffset(4, physics); }
  PhysicsComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PhysicsComponentBuilder &operator=(const PhysicsComponentBuilder &);
  flatbuffers::Offset<PhysicsComponent> Finish() {
    auto o = flatbuffers::Offset<PhysicsComponent>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<PhysicsComponent> CreatePhysicsComponent(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PhysicsObject>>> physics = 0) {
  PhysicsComponentBuilder builder_(_fbb);
  builder_.add_physics(physics);
  return builder_.Finish();
}

struct SoundListener FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SoundListenerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  SoundListenerBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SoundListenerBuilder &operator=(const SoundListenerBuilder &);
  flatbuffers::Offset<SoundListener> Finish() {
    auto o = flatbuffers::Offset<SoundListener>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<SoundListener> CreateSoundListener(flatbuffers::FlatBufferBuilder &_fbb) {
  SoundListenerBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Light FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Colour *colourDiffuse() const { return GetStruct<const Colour *>(4); }
  const Colour *colourSpecular() const { return GetStruct<const Colour *>(6); }
  const Vec3f *directionVector() const { return GetStruct<const Vec3f *>(8); }
  LightType lightType() const { return static_cast<LightType>(GetField<uint8_t>(10, 0)); }
  float powerScale() const { return GetField<float>(12, 0); }
  const AmbientLight *ambientLight() const { return GetPointer<const AmbientLight *>(14); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(16); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Colour>(verifier, 4 /* colourDiffuse */) &&
           VerifyField<Colour>(verifier, 6 /* colourSpecular */) &&
           VerifyField<Vec3f>(verifier, 8 /* directionVector */) &&
           VerifyField<uint8_t>(verifier, 10 /* lightType */) &&
           VerifyField<float>(verifier, 12 /* powerScale */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* ambientLight */) &&
           verifier.VerifyTable(ambientLight()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 16 /* name */) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct LightBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_colourDiffuse(const Colour *colourDiffuse) { fbb_.AddStruct(4, colourDiffuse); }
  void add_colourSpecular(const Colour *colourSpecular) { fbb_.AddStruct(6, colourSpecular); }
  void add_directionVector(const Vec3f *directionVector) { fbb_.AddStruct(8, directionVector); }
  void add_lightType(LightType lightType) { fbb_.AddElement<uint8_t>(10, static_cast<uint8_t>(lightType), 0); }
  void add_powerScale(float powerScale) { fbb_.AddElement<float>(12, powerScale, 0); }
  void add_ambientLight(flatbuffers::Offset<AmbientLight> ambientLight) { fbb_.AddOffset(14, ambientLight); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(16, name); }
  LightBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LightBuilder &operator=(const LightBuilder &);
  flatbuffers::Offset<Light> Finish() {
    auto o = flatbuffers::Offset<Light>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<Light> CreateLight(flatbuffers::FlatBufferBuilder &_fbb,
   const Colour *colourDiffuse = 0,
   const Colour *colourSpecular = 0,
   const Vec3f *directionVector = 0,
   LightType lightType = LightType_LT_DIRECTIONAL,
   float powerScale = 0,
   flatbuffers::Offset<AmbientLight> ambientLight = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0) {
  LightBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_ambientLight(ambientLight);
  builder_.add_powerScale(powerScale);
  builder_.add_directionVector(directionVector);
  builder_.add_colourSpecular(colourSpecular);
  builder_.add_colourDiffuse(colourDiffuse);
  builder_.add_lightType(lightType);
  return builder_.Finish();
}

struct Camera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Clipping *clipping() const { return GetPointer<const Clipping *>(4); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* clipping */) &&
           verifier.VerifyTable(clipping()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* name */) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct CameraBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clipping(flatbuffers::Offset<Clipping> clipping) { fbb_.AddOffset(4, clipping); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(6, name); }
  CameraBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CameraBuilder &operator=(const CameraBuilder &);
  flatbuffers::Offset<Camera> Finish() {
    auto o = flatbuffers::Offset<Camera>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Camera> CreateCamera(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<Clipping> clipping = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0) {
  CameraBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_clipping(clipping);
  return builder_.Finish();
}

struct System FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct SystemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  SystemBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SystemBuilder &operator=(const SystemBuilder &);
  flatbuffers::Offset<System> Finish() {
    auto o = flatbuffers::Offset<System>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<System> CreateSystem(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0) {
  SystemBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

struct AmbientLight FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Colour *upperHemisphere() const { return GetStruct<const Colour *>(4); }
  const Colour *lowerHemisphere() const { return GetStruct<const Colour *>(6); }
  const Vec3f *hemisphereDir() const { return GetStruct<const Vec3f *>(8); }
  float envmapScale() const { return GetField<float>(10, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Colour>(verifier, 4 /* upperHemisphere */) &&
           VerifyField<Colour>(verifier, 6 /* lowerHemisphere */) &&
           VerifyField<Vec3f>(verifier, 8 /* hemisphereDir */) &&
           VerifyField<float>(verifier, 10 /* envmapScale */) &&
           verifier.EndTable();
  }
};

struct AmbientLightBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_upperHemisphere(const Colour *upperHemisphere) { fbb_.AddStruct(4, upperHemisphere); }
  void add_lowerHemisphere(const Colour *lowerHemisphere) { fbb_.AddStruct(6, lowerHemisphere); }
  void add_hemisphereDir(const Vec3f *hemisphereDir) { fbb_.AddStruct(8, hemisphereDir); }
  void add_envmapScale(float envmapScale) { fbb_.AddElement<float>(10, envmapScale, 0); }
  AmbientLightBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AmbientLightBuilder &operator=(const AmbientLightBuilder &);
  flatbuffers::Offset<AmbientLight> Finish() {
    auto o = flatbuffers::Offset<AmbientLight>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AmbientLight> CreateAmbientLight(flatbuffers::FlatBufferBuilder &_fbb,
   const Colour *upperHemisphere = 0,
   const Colour *lowerHemisphere = 0,
   const Vec3f *hemisphereDir = 0,
   float envmapScale = 0) {
  AmbientLightBuilder builder_(_fbb);
  builder_.add_envmapScale(envmapScale);
  builder_.add_hemisphereDir(hemisphereDir);
  builder_.add_lowerHemisphere(lowerHemisphere);
  builder_.add_upperHemisphere(upperHemisphere);
  return builder_.Finish();
}

struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint16_t sceneid() const { return GetField<uint16_t>(4, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<System>> *systems() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<System>> *>(6); }
  const flatbuffers::String *type() const { return GetPointer<const flatbuffers::String *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* sceneid */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* systems */) &&
           verifier.Verify(systems()) &&
           verifier.VerifyVectorOfTables(systems()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* type */) &&
           verifier.Verify(type()) &&
           verifier.EndTable();
  }
};

struct SceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sceneid(uint16_t sceneid) { fbb_.AddElement<uint16_t>(4, sceneid, 0); }
  void add_systems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<System>>> systems) { fbb_.AddOffset(6, systems); }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) { fbb_.AddOffset(8, type); }
  SceneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SceneBuilder &operator=(const SceneBuilder &);
  flatbuffers::Offset<Scene> Finish() {
    auto o = flatbuffers::Offset<Scene>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Scene> CreateScene(flatbuffers::FlatBufferBuilder &_fbb,
   uint16_t sceneid = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<System>>> systems = 0,
   flatbuffers::Offset<flatbuffers::String> type = 0) {
  SceneBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_systems(systems);
  builder_.add_sceneid(sceneid);
  return builder_.Finish();
}

struct Animation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint32_t id() const { return GetField<uint32_t>(4, 0); }
  uint8_t loop() const { return GetField<uint8_t>(6, 0); }
  const flatbuffers::Vector<const AnimTrigger *> *triggers() const { return GetPointer<const flatbuffers::Vector<const AnimTrigger *> *>(8); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(10); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4 /* id */) &&
           VerifyField<uint8_t>(verifier, 6 /* loop */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* triggers */) &&
           verifier.Verify(triggers()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* name */) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct AnimationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) { fbb_.AddElement<uint32_t>(4, id, 0); }
  void add_loop(uint8_t loop) { fbb_.AddElement<uint8_t>(6, loop, 0); }
  void add_triggers(flatbuffers::Offset<flatbuffers::Vector<const AnimTrigger *>> triggers) { fbb_.AddOffset(8, triggers); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(10, name); }
  AnimationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimationBuilder &operator=(const AnimationBuilder &);
  flatbuffers::Offset<Animation> Finish() {
    auto o = flatbuffers::Offset<Animation>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<Animation> CreateAnimation(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t id = 0,
   uint8_t loop = 0,
   flatbuffers::Offset<flatbuffers::Vector<const AnimTrigger *>> triggers = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0) {
  AnimationBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_triggers(triggers);
  builder_.add_id(id);
  builder_.add_loop(loop);
  return builder_.Finish();
}

struct AnimationNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Animation *animation() const { return GetPointer<const Animation *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* animation */) &&
           verifier.VerifyTable(animation()) &&
           verifier.EndTable();
  }
};

struct AnimationNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_animation(flatbuffers::Offset<Animation> animation) { fbb_.AddOffset(4, animation); }
  AnimationNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimationNodeBuilder &operator=(const AnimationNodeBuilder &);
  flatbuffers::Offset<AnimationNode> Finish() {
    auto o = flatbuffers::Offset<AnimationNode>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<AnimationNode> CreateAnimationNode(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<Animation> animation = 0) {
  AnimationNodeBuilder builder_(_fbb);
  builder_.add_animation(animation);
  return builder_.Finish();
}

struct ParameterNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Parameter *param() const { return GetStruct<const Parameter *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Parameter>(verifier, 4 /* param */) &&
           verifier.EndTable();
  }
};

struct ParameterNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_param(const Parameter *param) { fbb_.AddStruct(4, param); }
  ParameterNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ParameterNodeBuilder &operator=(const ParameterNodeBuilder &);
  flatbuffers::Offset<ParameterNode> Finish() {
    auto o = flatbuffers::Offset<ParameterNode>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ParameterNode> CreateParameterNode(flatbuffers::FlatBufferBuilder &_fbb,
   const Parameter *param = 0) {
  ParameterNodeBuilder builder_(_fbb);
  builder_.add_param(param);
  return builder_.Finish();
}

struct TransitionSelectNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint16_t select() const { return GetField<uint16_t>(4, 0); }
  float timeIn() const { return GetField<float>(6, 0); }
  float timeOut() const { return GetField<float>(8, 0); }
  uint16_t size() const { return GetField<uint16_t>(10, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* select */) &&
           VerifyField<float>(verifier, 6 /* timeIn */) &&
           VerifyField<float>(verifier, 8 /* timeOut */) &&
           VerifyField<uint16_t>(verifier, 10 /* size */) &&
           verifier.EndTable();
  }
};

struct TransitionSelectNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_select(uint16_t select) { fbb_.AddElement<uint16_t>(4, select, 0); }
  void add_timeIn(float timeIn) { fbb_.AddElement<float>(6, timeIn, 0); }
  void add_timeOut(float timeOut) { fbb_.AddElement<float>(8, timeOut, 0); }
  void add_size(uint16_t size) { fbb_.AddElement<uint16_t>(10, size, 0); }
  TransitionSelectNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TransitionSelectNodeBuilder &operator=(const TransitionSelectNodeBuilder &);
  flatbuffers::Offset<TransitionSelectNode> Finish() {
    auto o = flatbuffers::Offset<TransitionSelectNode>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<TransitionSelectNode> CreateTransitionSelectNode(flatbuffers::FlatBufferBuilder &_fbb,
   uint16_t select = 0,
   float timeIn = 0,
   float timeOut = 0,
   uint16_t size = 0) {
  TransitionSelectNodeBuilder builder_(_fbb);
  builder_.add_timeOut(timeOut);
  builder_.add_timeIn(timeIn);
  builder_.add_size(size);
  builder_.add_select(select);
  return builder_.Finish();
}

struct AverageNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint16_t size() const { return GetField<uint16_t>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* size */) &&
           verifier.EndTable();
  }
};

struct AverageNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(uint16_t size) { fbb_.AddElement<uint16_t>(4, size, 0); }
  AverageNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AverageNodeBuilder &operator=(const AverageNodeBuilder &);
  flatbuffers::Offset<AverageNode> Finish() {
    auto o = flatbuffers::Offset<AverageNode>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<AverageNode> CreateAverageNode(flatbuffers::FlatBufferBuilder &_fbb,
   uint16_t size = 0) {
  AverageNodeBuilder builder_(_fbb);
  builder_.add_size(size);
  return builder_.Finish();
}

struct MaskAddNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MaskAddNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  MaskAddNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MaskAddNodeBuilder &operator=(const MaskAddNodeBuilder &);
  flatbuffers::Offset<MaskAddNode> Finish() {
    auto o = flatbuffers::Offset<MaskAddNode>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<MaskAddNode> CreateMaskAddNode(flatbuffers::FlatBufferBuilder &_fbb) {
  MaskAddNodeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SmoothValueNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  float initial_value() const { return GetField<float>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4 /* initial_value */) &&
           verifier.EndTable();
  }
};

struct SmoothValueNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_initial_value(float initial_value) { fbb_.AddElement<float>(4, initial_value, 0); }
  SmoothValueNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SmoothValueNodeBuilder &operator=(const SmoothValueNodeBuilder &);
  flatbuffers::Offset<SmoothValueNode> Finish() {
    auto o = flatbuffers::Offset<SmoothValueNode>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<SmoothValueNode> CreateSmoothValueNode(flatbuffers::FlatBufferBuilder &_fbb,
   float initial_value = 0) {
  SmoothValueNodeBuilder builder_(_fbb);
  builder_.add_initial_value(initial_value);
  return builder_.Finish();
}

struct LookAtNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LookAtNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  LookAtNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LookAtNodeBuilder &operator=(const LookAtNodeBuilder &);
  flatbuffers::Offset<LookAtNode> Finish() {
    auto o = flatbuffers::Offset<LookAtNode>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<LookAtNode> CreateLookAtNode(flatbuffers::FlatBufferBuilder &_fbb) {
  LookAtNodeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RandomSelectNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint16_t size() const { return GetField<uint16_t>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* size */) &&
           verifier.EndTable();
  }
};

struct RandomSelectNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(uint16_t size) { fbb_.AddElement<uint16_t>(4, size, 0); }
  RandomSelectNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RandomSelectNodeBuilder &operator=(const RandomSelectNodeBuilder &);
  flatbuffers::Offset<RandomSelectNode> Finish() {
    auto o = flatbuffers::Offset<RandomSelectNode>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<RandomSelectNode> CreateRandomSelectNode(flatbuffers::FlatBufferBuilder &_fbb,
   uint16_t size = 0) {
  RandomSelectNodeBuilder builder_(_fbb);
  builder_.add_size(size);
  return builder_.Finish();
}

struct MixNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint16_t size() const { return GetField<uint16_t>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* size */) &&
           verifier.EndTable();
  }
};

struct MixNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(uint16_t size) { fbb_.AddElement<uint16_t>(4, size, 0); }
  MixNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MixNodeBuilder &operator=(const MixNodeBuilder &);
  flatbuffers::Offset<MixNode> Finish() {
    auto o = flatbuffers::Offset<MixNode>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<MixNode> CreateMixNode(flatbuffers::FlatBufferBuilder &_fbb,
   uint16_t size = 0) {
  MixNodeBuilder builder_(_fbb);
  builder_.add_size(size);
  return builder_.Finish();
}

struct AnimNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint32_t id() const { return GetField<uint32_t>(4, 0); }
  UAnimationNode node_type() const { return static_cast<UAnimationNode>(GetField<uint8_t>(6, 0)); }
  const void *node() const { return GetPointer<const void *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4 /* id */) &&
           VerifyField<uint8_t>(verifier, 6 /* node_type */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* node */) &&
           VerifyUAnimationNode(verifier, node(), node_type()) &&
           verifier.EndTable();
  }
};

struct AnimNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) { fbb_.AddElement<uint32_t>(4, id, 0); }
  void add_node_type(UAnimationNode node_type) { fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(node_type), 0); }
  void add_node(flatbuffers::Offset<void> node) { fbb_.AddOffset(8, node); }
  AnimNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimNodeBuilder &operator=(const AnimNodeBuilder &);
  flatbuffers::Offset<AnimNode> Finish() {
    auto o = flatbuffers::Offset<AnimNode>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<AnimNode> CreateAnimNode(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t id = 0,
   UAnimationNode node_type = UAnimationNode_NONE,
   flatbuffers::Offset<void> node = 0) {
  AnimNodeBuilder builder_(_fbb);
  builder_.add_node(node);
  builder_.add_id(id);
  builder_.add_node_type(node_type);
  return builder_.Finish();
}

struct BodyComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Vec3f *position() const { return GetStruct<const Vec3f *>(4); }
  const Quat4f *rotation() const { return GetStruct<const Quat4f *>(6); }
  const Vec3f *scale() const { return GetStruct<const Vec3f *>(8); }
  uint32_t sceneId() const { return GetField<uint32_t>(10, 0); }
  uint8_t visible() const { return GetField<uint8_t>(12, 1); }
  uint8_t enabled() const { return GetField<uint8_t>(14, 1); }
  uint32_t group() const { return GetField<uint32_t>(16, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3f>(verifier, 4 /* position */) &&
           VerifyField<Quat4f>(verifier, 6 /* rotation */) &&
           VerifyField<Vec3f>(verifier, 8 /* scale */) &&
           VerifyField<uint32_t>(verifier, 10 /* sceneId */) &&
           VerifyField<uint8_t>(verifier, 12 /* visible */) &&
           VerifyField<uint8_t>(verifier, 14 /* enabled */) &&
           VerifyField<uint32_t>(verifier, 16 /* group */) &&
           verifier.EndTable();
  }
};

struct BodyComponentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const Vec3f *position) { fbb_.AddStruct(4, position); }
  void add_rotation(const Quat4f *rotation) { fbb_.AddStruct(6, rotation); }
  void add_scale(const Vec3f *scale) { fbb_.AddStruct(8, scale); }
  void add_sceneId(uint32_t sceneId) { fbb_.AddElement<uint32_t>(10, sceneId, 0); }
  void add_visible(uint8_t visible) { fbb_.AddElement<uint8_t>(12, visible, 1); }
  void add_enabled(uint8_t enabled) { fbb_.AddElement<uint8_t>(14, enabled, 1); }
  void add_group(uint32_t group) { fbb_.AddElement<uint32_t>(16, group, 0); }
  BodyComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BodyComponentBuilder &operator=(const BodyComponentBuilder &);
  flatbuffers::Offset<BodyComponent> Finish() {
    auto o = flatbuffers::Offset<BodyComponent>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<BodyComponent> CreateBodyComponent(flatbuffers::FlatBufferBuilder &_fbb,
   const Vec3f *position = 0,
   const Quat4f *rotation = 0,
   const Vec3f *scale = 0,
   uint32_t sceneId = 0,
   uint8_t visible = 1,
   uint8_t enabled = 1,
   uint32_t group = 0) {
  BodyComponentBuilder builder_(_fbb);
  builder_.add_group(group);
  builder_.add_sceneId(sceneId);
  builder_.add_scale(scale);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_enabled(enabled);
  builder_.add_visible(visible);
  return builder_.Finish();
}

struct AnimationComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *animationTree() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::String *animationInfo() const { return GetPointer<const flatbuffers::String *>(6); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimNode>> *nodes() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimNode>> *>(8); }
  const flatbuffers::Vector<const Connection *> *connections() const { return GetPointer<const flatbuffers::Vector<const Connection *> *>(10); }
  const flatbuffers::Vector<const Constant *> *constants() const { return GetPointer<const flatbuffers::Vector<const Constant *> *>(12); }
  const flatbuffers::String *boneparent() const { return GetPointer<const flatbuffers::String *>(14); }
  uint32_t output() const { return GetField<uint32_t>(16, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* animationTree */) &&
           verifier.Verify(animationTree()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* animationInfo */) &&
           verifier.Verify(animationInfo()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* nodes */) &&
           verifier.Verify(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* connections */) &&
           verifier.Verify(connections()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* constants */) &&
           verifier.Verify(constants()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* boneparent */) &&
           verifier.Verify(boneparent()) &&
           VerifyField<uint32_t>(verifier, 16 /* output */) &&
           verifier.EndTable();
  }
};

struct AnimationComponentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_animationTree(flatbuffers::Offset<flatbuffers::String> animationTree) { fbb_.AddOffset(4, animationTree); }
  void add_animationInfo(flatbuffers::Offset<flatbuffers::String> animationInfo) { fbb_.AddOffset(6, animationInfo); }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimNode>>> nodes) { fbb_.AddOffset(8, nodes); }
  void add_connections(flatbuffers::Offset<flatbuffers::Vector<const Connection *>> connections) { fbb_.AddOffset(10, connections); }
  void add_constants(flatbuffers::Offset<flatbuffers::Vector<const Constant *>> constants) { fbb_.AddOffset(12, constants); }
  void add_boneparent(flatbuffers::Offset<flatbuffers::String> boneparent) { fbb_.AddOffset(14, boneparent); }
  void add_output(uint32_t output) { fbb_.AddElement<uint32_t>(16, output, 0); }
  AnimationComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimationComponentBuilder &operator=(const AnimationComponentBuilder &);
  flatbuffers::Offset<AnimationComponent> Finish() {
    auto o = flatbuffers::Offset<AnimationComponent>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<AnimationComponent> CreateAnimationComponent(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> animationTree = 0,
   flatbuffers::Offset<flatbuffers::String> animationInfo = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimNode>>> nodes = 0,
   flatbuffers::Offset<flatbuffers::Vector<const Connection *>> connections = 0,
   flatbuffers::Offset<flatbuffers::Vector<const Constant *>> constants = 0,
   flatbuffers::Offset<flatbuffers::String> boneparent = 0,
   uint32_t output = 0) {
  AnimationComponentBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_boneparent(boneparent);
  builder_.add_constants(constants);
  builder_.add_connections(connections);
  builder_.add_nodes(nodes);
  builder_.add_animationInfo(animationInfo);
  builder_.add_animationTree(animationTree);
  return builder_.Finish();
}

struct SoundComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<Sound>> *sounds() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Sound>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* sounds */) &&
           verifier.Verify(sounds()) &&
           verifier.VerifyVectorOfTables(sounds()) &&
           verifier.EndTable();
  }
};

struct SoundComponentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sounds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sound>>> sounds) { fbb_.AddOffset(4, sounds); }
  SoundComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SoundComponentBuilder &operator=(const SoundComponentBuilder &);
  flatbuffers::Offset<SoundComponent> Finish() {
    auto o = flatbuffers::Offset<SoundComponent>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<SoundComponent> CreateSoundComponent(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sound>>> sounds = 0) {
  SoundComponentBuilder builder_(_fbb);
  builder_.add_sounds(sounds);
  return builder_.Finish();
}

inline bool VerifyUMesh(flatbuffers::Verifier &verifier, const void *union_obj, UMesh type) {
  switch (type) {
    case UMesh_NONE: return true;
    case UMesh_MeshFile: return verifier.VerifyTable(reinterpret_cast<const MeshFile *>(union_obj));
    case UMesh_MeshCube: return verifier.VerifyTable(reinterpret_cast<const MeshCube *>(union_obj));
    case UMesh_MeshPlane: return verifier.VerifyTable(reinterpret_cast<const MeshPlane *>(union_obj));
    case UMesh_MeshSphere: return verifier.VerifyTable(reinterpret_cast<const MeshSphere *>(union_obj));
    default: return false;
  }
}

inline bool VerifyUAnimationNode(flatbuffers::Verifier &verifier, const void *union_obj, UAnimationNode type) {
  switch (type) {
    case UAnimationNode_NONE: return true;
    case UAnimationNode_AnimationNode: return verifier.VerifyTable(reinterpret_cast<const AnimationNode *>(union_obj));
    case UAnimationNode_TransitionSelectNode: return verifier.VerifyTable(reinterpret_cast<const TransitionSelectNode *>(union_obj));
    case UAnimationNode_LookAtNode: return verifier.VerifyTable(reinterpret_cast<const LookAtNode *>(union_obj));
    case UAnimationNode_MixNode: return verifier.VerifyTable(reinterpret_cast<const MixNode *>(union_obj));
    case UAnimationNode_ParameterNode: return verifier.VerifyTable(reinterpret_cast<const ParameterNode *>(union_obj));
    case UAnimationNode_AverageNode: return verifier.VerifyTable(reinterpret_cast<const AverageNode *>(union_obj));
    case UAnimationNode_MaskAddNode: return verifier.VerifyTable(reinterpret_cast<const MaskAddNode *>(union_obj));
    case UAnimationNode_RandomSelectNode: return verifier.VerifyTable(reinterpret_cast<const RandomSelectNode *>(union_obj));
    case UAnimationNode_SmoothValueNode: return verifier.VerifyTable(reinterpret_cast<const SmoothValueNode *>(union_obj));
    default: return false;
  }
}

}  // namespace XFBType

#endif  // FLATBUFFERS_GENERATED_FBENGINETYPES_XFBTYPE_H_
