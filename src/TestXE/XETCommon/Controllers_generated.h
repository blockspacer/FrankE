// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CONTROLLERS_CONTROLLERSETTINGS_H_
#define FLATBUFFERS_GENERATED_CONTROLLERS_CONTROLLERSETTINGS_H_

#include "flatbuffers/flatbuffers.h"


namespace ControllerSettings {

struct Event;
struct Action;
struct ControllerMap;
struct ControllerList;

enum Button {
  Button_None = -1,
  Button_Left = 0,
  Button_Right = 1,
  Button_Middle = 2,
  ///< The middle (wheel) mouse button  
  ///< The first extra mouse button
  Button_XButton1 = 3,
  ///< The second extra mouse button
  Button_XButton2 = 4,
  ///< Keep last -- the total number of mouse buttons
  Button_ButtonCount = 5
};

inline const char **EnumNamesButton() {
  static const char *names[] = { "None", "Left", "Right", "Middle", "XButton1", "XButton2", "ButtonCount", nullptr };
  return names;
}

inline const char *EnumNameButton(Button e) { return EnumNamesButton()[static_cast<int>(e) - static_cast<int>(Button_None)]; }

enum Axis {
  Axis_None = -1,
  Axis_X = 0,
  Axis_Y = 1,
  Axis_Z = 2,
  Axis_R = 3,
  Axis_U = 4,
  Axis_V = 5,
  ///< The X axis of the point-of-view hat
  Axis_PovX = 6,
  ///< The Y axis of the point-of-view hat
  Axis_PovY = 7
};

inline const char **EnumNamesAxis() {
  static const char *names[] = { "None", "X", "Y", "Z", "R", "U", "V", "PovX", "PovY", nullptr };
  return names;
}

inline const char *EnumNameAxis(Axis e) { return EnumNamesAxis()[static_cast<int>(e) - static_cast<int>(Axis_None)]; }

enum KeyID {
  ///< Unhandled key fb array index starts with 0!
  KeyID_None = -1,
  KeyID_A = 0,
  KeyID_B = 1,
  KeyID_C = 2,
  KeyID_D = 3,
  KeyID_E = 4,
  KeyID_F = 5,
  KeyID_G = 6,
  KeyID_H = 7,
  KeyID_I = 8,
  KeyID_J = 9,
  KeyID_K = 10,
  KeyID_L = 11,
  KeyID_M = 12,
  KeyID_N = 13,
  KeyID_O = 14,
  KeyID_P = 15,
  KeyID_Q = 16,
  KeyID_R = 17,
  KeyID_S = 18,
  KeyID_T = 19,
  KeyID_U = 20,
  KeyID_V = 21,
  KeyID_W = 22,
  KeyID_X = 23,
  KeyID_Y = 24,
  KeyID_Z = 25,
  KeyID_Num0 = 26,
  KeyID_Num1 = 27,
  KeyID_Num2 = 28,
  KeyID_Num3 = 29,
  KeyID_Num4 = 30,
  KeyID_Num5 = 31,
  KeyID_Num6 = 32,
  KeyID_Num7 = 33,
  KeyID_Num8 = 34,
  KeyID_Num9 = 35,
  ///< The Escape key
  KeyID_Escape = 36,
  ///< The left Control key
  KeyID_LControl = 37,
  ///< The left Shift key
  KeyID_LShift = 38,
  ///< The left Alt key
  KeyID_LAlt = 39,
  KeyID_LSystem = 40,
  ///< The right Control key
  KeyID_RControl = 41,
  ///< The right Shift key
  KeyID_RShift = 42,
  ///< The right Alt key
  KeyID_RAlt = 43,
  ///< The right OS specific key: window (Windows and Linux), apple (MacOS X), ...   
  KeyID_RSystem = 44,
  ///< The Menu key  
  KeyID_Menu = 45,
  ///< The [ key  
  KeyID_LBracket = 46,
  ///< The ] key 
  KeyID_RBracket = 47,
  ///< The ; key 
  KeyID_SemiColon = 48,
  ///< The , key
  KeyID_Comma = 49,
  ///< The . key
  KeyID_Period = 50,
  ///< The ' key
  KeyID_Quote = 51,
  ///< The / key
  KeyID_Slash = 52,
  ///< The \ key
  KeyID_BackSlash = 53,
  ///< The ~ key
  KeyID_Tilde = 54,
  ///< The = key
  KeyID_Equal = 55,
  ///< The - key
  KeyID_Dash = 56,
  ///< The Space key    
  KeyID_Space = 57,
  ///< The Return key
  KeyID_Return = 58,
  ///< The Backspace key
  KeyID_BackSpace = 59,
  ///< The Tabulation key
  KeyID_Tab = 60,
  ///< The Page up key    
  KeyID_PageUp = 61,
  ///< The Page down key
  KeyID_PageDown = 62,
  ///< The End key
  KeyID_End = 63,
  ///< The Home key
  KeyID_Home = 64,
  ///< The Insert key
  KeyID_Insert = 65,
  ///< The Delete key
  KeyID_Delete = 66,
  ///< The + key     
  KeyID_Add = 67,
  ///< The - key   
  KeyID_Subtract = 68,
  ///< The * key
  KeyID_Multiply = 69,
  ///< The / key   
  KeyID_Divide = 70,
  ///< Left arrow
  KeyID_Left = 71,
  ///< Right arrow
  KeyID_Right = 72,
  ///< Up arrow
  KeyID_Up = 73,
  ///< Down arrow
  KeyID_Down = 74,
  ///< The numpad 0 key
  KeyID_Numpad0 = 75,
  ///< The numpad 1 key 
  KeyID_Numpad1 = 76,
  ///< The numpad 2 key 
  KeyID_Numpad2 = 77,
  ///< The numpad 3 key
  KeyID_Numpad3 = 78,
  ///< The numpad 4 key 
  KeyID_Numpad4 = 79,
  ///< The numpad 5 key  
  KeyID_Numpad5 = 80,
  ///< The numpad 6 key
  KeyID_Numpad6 = 81,
  ///< The numpad 7 key
  KeyID_Numpad7 = 82,
  ///< The  numpad 8 key
  KeyID_Numpad8 = 83,
  ///< The numpad 9 key
  KeyID_Numpad9 = 84,
  KeyID_F1 = 85,
  KeyID_F2 = 86,
  KeyID_F3 = 87,
  KeyID_F4 = 88,
  KeyID_F5 = 89,
  KeyID_F6 = 90,
  KeyID_F7 = 91,
  KeyID_F8 = 92,
  KeyID_F9 = 93,
  KeyID_F10 = 94,
  KeyID_F11 = 95,
  KeyID_F12 = 96,
  KeyID_F13 = 97,
  KeyID_F14 = 98,
  KeyID_F15 = 99,
  ///< The Pause key
  KeyID_Pause = 100,
  ///< Keep last -- the total number of keyboard keys
  KeyID_KeyCount = 101
};

inline const char **EnumNamesKeyID() {
  static const char *names[] = { "None", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "Num0", "Num1", "Num2", "Num3", "Num4", "Num5", "Num6", "Num7", "Num8", "Num9", "Escape", "LControl", "LShift", "LAlt", "LSystem", "RControl", "RShift", "RAlt", "RSystem", "Menu", "LBracket", "RBracket", "SemiColon", "Comma", "Period", "Quote", "Slash", "BackSlash", "Tilde", "Equal", "Dash", "Space", "Return", "BackSpace", "Tab", "PageUp", "PageDown", "End", "Home", "Insert", "Delete", "Add", "Subtract", "Multiply", "Divide", "Left", "Right", "Up", "Down", "Numpad0", "Numpad1", "Numpad2", "Numpad3", "Numpad4", "Numpad5", "Numpad6", "Numpad7", "Numpad8", "Numpad9", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "Pause", "KeyCount", nullptr };
  return names;
}

inline const char *EnumNameKeyID(KeyID e) { return EnumNamesKeyID()[static_cast<int>(e) - static_cast<int>(KeyID_None)]; }

enum ActionType {
  ActionType_None = 0,
  ///< move forward
  ActionType_Forward = 1,
  ///< move ForwardLeft
  ActionType_ForwardLeft = 2,
  ///< move ForwardRight
  ActionType_ForwardRight = 3,
  ///< move backward
  ActionType_Backward = 4,
  ///< move BackwardLeft
  ActionType_BackwardLeft = 5,
  ///< move BackwardRight
  ActionType_BackwardRight = 6,
  ///< TurnLeft
  ActionType_TurnLeft = 7,
  ///< TurnRight
  ActionType_TurnRight = 8,
  ///< StrafeLeft
  ActionType_StrafeLeft = 9,
  ///< StrafeRight
  ActionType_StrafeRight = 10,
  ///< Jump
  ActionType_Jump = 11,
  ///< Run
  ActionType_Run = 12,
  ///< Walk
  ActionType_Walk = 13,
  ///< Next Target
  ActionType_NextTarget = 14,
  ///< Preview Target
  ActionType_PrevTarget = 15,
  ///< Punch1
  ActionType_Punch1 = 16,
  ///< Kick1
  ActionType_Kick1 = 17,
  ///< Entity mit Camera drehen
  ActionType_ObjRotate = 18,
  ///< ZoomIn
  ActionType_ZoomIn = 19,
  ///< ZoomOut
  ActionType_ZoomOut = 20,
  ///< Rotate Camera
  ActionType_CamRotate = 21,
  ///< Point selection
  ActionType_PointSelectStart = 22,
  ///< Point selection
  ActionType_PointSelectEnd = 23,
  ///< Point selection
  ActionType_PointMoved = 24,
  ///< Spell 1
  ActionType_Spell1 = 25,
  ///< Spell 2
  ActionType_Spell2 = 26,
  ///< Spell 3
  ActionType_Spell3 = 27,
  ///< Aktion 1
  ActionType_Action1 = 28,
  ///< Aktion 2	
  ActionType_Action2 = 29,
  ///< Menu NavigationUP 
  ActionType_NavUp = 30,
  ///< Menu NavigationDown 				
  ActionType_NavDown = 31,
  ///< Menu NavigationLeft 			
  ActionType_NavLeft = 32,
  ///< Menu NavigationRight 	
  ActionType_NavRight = 33,
  ///< Menu Navigation selection
  ActionType_NavSelect = 34,
  ActionType_NavEnter = 35,
  ActionType_TextEntered = 36,
  ActionType_KeyPressed = 37,
  ActionType_Shoot = 38,
  ActionType_Resized = 39,
  ActionType_Quit = 40
};

inline const char **EnumNamesActionType() {
  static const char *names[] = { "None", "Forward", "ForwardLeft", "ForwardRight", "Backward", "BackwardLeft", "BackwardRight", "TurnLeft", "TurnRight", "StrafeLeft", "StrafeRight", "Jump", "Run", "Walk", "NextTarget", "PrevTarget", "Punch1", "Kick1", "ObjRotate", "ZoomIn", "ZoomOut", "CamRotate", "PointSelectStart", "PointSelectEnd", "PointMoved", "Spell1", "Spell2", "Spell3", "Action1", "Action2", "NavUp", "NavDown", "NavLeft", "NavRight", "NavSelect", "NavEnter", "TextEntered", "KeyPressed", "Shoot", "Resized", "Quit", nullptr };
  return names;
}

inline const char *EnumNameActionType(ActionType e) { return EnumNamesActionType()[static_cast<int>(e)]; }

enum DeviceType {
  DeviceType_DT_unknown = 0,
  DeviceType_DT_KeyMouse = 1,
  DeviceType_DT_Joy = 2,
  DeviceType_DT_Gamepad = 3,
  DeviceType_DT_count = 4
};

inline const char **EnumNamesDeviceType() {
  static const char *names[] = { "DT_unknown", "DT_KeyMouse", "DT_Joy", "DT_Gamepad", "DT_count", nullptr };
  return names;
}

inline const char *EnumNameDeviceType(DeviceType e) { return EnumNamesDeviceType()[static_cast<int>(e)]; }

enum MouseWheelEvent {
  MouseWheelEvent_None = -1,
  MouseWheelEvent_Plus = 0,
  MouseWheelEvent_Substract = 1
};

inline const char **EnumNamesMouseWheelEvent() {
  static const char *names[] = { "None", "Plus", "Substract", nullptr };
  return names;
}

inline const char *EnumNameMouseWheelEvent(MouseWheelEvent e) { return EnumNamesMouseWheelEvent()[static_cast<int>(e) - static_cast<int>(MouseWheelEvent_None)]; }

enum ActionOperator {
  ActionOperator_Or = 0,
  ActionOperator_And = 1
};

inline const char **EnumNamesActionOperator() {
  static const char *names[] = { "Or", "And", nullptr };
  return names;
}

inline const char *EnumNameActionOperator(ActionOperator e) { return EnumNamesActionOperator()[static_cast<int>(e)]; }

enum EventType {
  ///< Repeated input (e.g. a key that is held down).
  EventType_Hold = 0,
  ///< Press events that occur only once (e.g. key pressed).
  EventType_PressOnce = 1,
  ///< Release events that occur only once (e.g. key released).
  EventType_ReleaseOnce = 2
};

inline const char **EnumNamesEventType() {
  static const char *names[] = { "Hold", "PressOnce", "ReleaseOnce", nullptr };
  return names;
}

inline const char *EnumNameEventType(EventType e) { return EnumNamesEventType()[static_cast<int>(e)]; }

struct Event FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  ActionOperator actionOperator() const { return static_cast<ActionOperator>(GetField<uint16_t>(4, 0)); }
  KeyID kCode() const { return static_cast<KeyID>(GetField<int16_t>(6, -1)); }
  Button mouse() const { return static_cast<Button>(GetField<int16_t>(8, -1)); }
  MouseWheelEvent mWheel() const { return static_cast<MouseWheelEvent>(GetField<int16_t>(10, -1)); }
  Axis joy() const { return static_cast<Axis>(GetField<int16_t>(12, -1)); }
  int16_t joyBtn() const { return GetField<int16_t>(14, -1); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* actionOperator */) &&
           VerifyField<int16_t>(verifier, 6 /* kCode */) &&
           VerifyField<int16_t>(verifier, 8 /* mouse */) &&
           VerifyField<int16_t>(verifier, 10 /* mWheel */) &&
           VerifyField<int16_t>(verifier, 12 /* joy */) &&
           VerifyField<int16_t>(verifier, 14 /* joyBtn */) &&
           verifier.EndTable();
  }
};

struct EventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actionOperator(ActionOperator actionOperator) { fbb_.AddElement<uint16_t>(4, static_cast<uint16_t>(actionOperator), 0); }
  void add_kCode(KeyID kCode) { fbb_.AddElement<int16_t>(6, static_cast<int16_t>(kCode), -1); }
  void add_mouse(Button mouse) { fbb_.AddElement<int16_t>(8, static_cast<int16_t>(mouse), -1); }
  void add_mWheel(MouseWheelEvent mWheel) { fbb_.AddElement<int16_t>(10, static_cast<int16_t>(mWheel), -1); }
  void add_joy(Axis joy) { fbb_.AddElement<int16_t>(12, static_cast<int16_t>(joy), -1); }
  void add_joyBtn(int16_t joyBtn) { fbb_.AddElement<int16_t>(14, joyBtn, -1); }
  EventBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EventBuilder &operator=(const EventBuilder &);
  flatbuffers::Offset<Event> Finish() {
    auto o = flatbuffers::Offset<Event>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<Event> CreateEvent(flatbuffers::FlatBufferBuilder &_fbb,
   ActionOperator actionOperator = ActionOperator_Or,
   KeyID kCode = KeyID_None,
   Button mouse = Button_None,
   MouseWheelEvent mWheel = MouseWheelEvent_None,
   Axis joy = Axis_None,
   int16_t joyBtn = -1) {
  EventBuilder builder_(_fbb);
  builder_.add_joyBtn(joyBtn);
  builder_.add_joy(joy);
  builder_.add_mWheel(mWheel);
  builder_.add_mouse(mouse);
  builder_.add_kCode(kCode);
  builder_.add_actionOperator(actionOperator);
  return builder_.Finish();
}

struct Action FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  ActionType actionType() const { return static_cast<ActionType>(GetField<uint16_t>(4, 0)); }
  EventType eventType() const { return static_cast<EventType>(GetField<int16_t>(6, 0)); }
  const flatbuffers::Vector<flatbuffers::Offset<Event>> *events() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Event>> *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* actionType */) &&
           VerifyField<int16_t>(verifier, 6 /* eventType */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* events */) &&
           verifier.Verify(events()) &&
           verifier.VerifyVectorOfTables(events()) &&
           verifier.EndTable();
  }
};

struct ActionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actionType(ActionType actionType) { fbb_.AddElement<uint16_t>(4, static_cast<uint16_t>(actionType), 0); }
  void add_eventType(EventType eventType) { fbb_.AddElement<int16_t>(6, static_cast<int16_t>(eventType), 0); }
  void add_events(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Event>>> events) { fbb_.AddOffset(8, events); }
  ActionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ActionBuilder &operator=(const ActionBuilder &);
  flatbuffers::Offset<Action> Finish() {
    auto o = flatbuffers::Offset<Action>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Action> CreateAction(flatbuffers::FlatBufferBuilder &_fbb,
   ActionType actionType = ActionType_None,
   EventType eventType = EventType_Hold,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Event>>> events = 0) {
  ActionBuilder builder_(_fbb);
  builder_.add_events(events);
  builder_.add_eventType(eventType);
  builder_.add_actionType(actionType);
  return builder_.Finish();
}

struct ControllerMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  DeviceType type() const { return static_cast<DeviceType>(GetField<uint16_t>(4, 0)); }
  const flatbuffers::Vector<flatbuffers::Offset<Action>> *actionMap() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Action>> *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* type */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* actionMap */) &&
           verifier.Verify(actionMap()) &&
           verifier.VerifyVectorOfTables(actionMap()) &&
           verifier.EndTable();
  }
};

struct ControllerMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(DeviceType type) { fbb_.AddElement<uint16_t>(4, static_cast<uint16_t>(type), 0); }
  void add_actionMap(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Action>>> actionMap) { fbb_.AddOffset(6, actionMap); }
  ControllerMapBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ControllerMapBuilder &operator=(const ControllerMapBuilder &);
  flatbuffers::Offset<ControllerMap> Finish() {
    auto o = flatbuffers::Offset<ControllerMap>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ControllerMap> CreateControllerMap(flatbuffers::FlatBufferBuilder &_fbb,
   DeviceType type = DeviceType_DT_unknown,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Action>>> actionMap = 0) {
  ControllerMapBuilder builder_(_fbb);
  builder_.add_actionMap(actionMap);
  builder_.add_type(type);
  return builder_.Finish();
}

struct ControllerList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<ControllerMap>> *ctrlList() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ControllerMap>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* ctrlList */) &&
           verifier.Verify(ctrlList()) &&
           verifier.VerifyVectorOfTables(ctrlList()) &&
           verifier.EndTable();
  }
};

struct ControllerListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ctrlList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ControllerMap>>> ctrlList) { fbb_.AddOffset(4, ctrlList); }
  ControllerListBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ControllerListBuilder &operator=(const ControllerListBuilder &);
  flatbuffers::Offset<ControllerList> Finish() {
    auto o = flatbuffers::Offset<ControllerList>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ControllerList> CreateControllerList(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ControllerMap>>> ctrlList = 0) {
  ControllerListBuilder builder_(_fbb);
  builder_.add_ctrlList(ctrlList);
  return builder_.Finish();
}

inline const ControllerSettings::ControllerList *GetControllerList(const void *buf) { return flatbuffers::GetRoot<ControllerSettings::ControllerList>(buf); }

inline bool VerifyControllerListBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<ControllerSettings::ControllerList>(); }

inline void FinishControllerListBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<ControllerSettings::ControllerList> root) { fbb.Finish(root); }

}  // namespace ControllerSettings

#endif  // FLATBUFFERS_GENERATED_CONTROLLERS_CONTROLLERSETTINGS_H_
